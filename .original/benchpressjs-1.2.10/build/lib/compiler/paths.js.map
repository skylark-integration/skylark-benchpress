{"version":3,"sources":["../../../lib/compiler/paths.js"],"names":["relative","basePath","relPath","backPattern","rel","replace","path","test","resolve","base","split","found","relStart","baseLen","l","length","j","i","slice","concat","join","exports"],"mappings":"AAAA;;AAEA,SAASA,QAAT,CAAkBC,QAAlB,EAA4BC,OAA5B,EAAqC;AACnC,QAAMC,WAAW,GAAG,aAApB;AACA,QAAMC,GAAG,GAAGF,OAAO,CAACG,OAAR,CAAgB,UAAhB,EAA4B,EAA5B,CAAZ;AACA,MAAIC,IAAJ;;AACA,MAAI,CAACL,QAAL,EAAe;AACbK,IAAAA,IAAI,GAAI,GAAEF,GAAG,CAACC,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,CAAuB,EAAjC;AACD,GAFD,MAEO;AACLC,IAAAA,IAAI,GAAI,GAAEL,QAAS,IAAGG,GAAG,CAACC,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,CAAuB,EAA7C;AACD;;AACD,SAAOF,WAAW,CAACI,IAAZ,CAAiBD,IAAjB,CAAP,EAA+B;AAC7BA,IAAAA,IAAI,GAAGA,IAAI,CAACD,OAAL,CAAaF,WAAb,EAA0B,EAA1B,CAAP;AACD;;AAED,SAAOG,IAAP;AACD;AAED;;;;;;;AAKA,SAASE,OAAT,CAAiBP,QAAjB,EAA2BC,OAA3B,EAAoC;AAClC;AACA,MAAI,WAAWK,IAAX,CAAgBL,OAAhB,CAAJ,EAA8B;AAC5B,WAAOF,QAAQ,CAACC,QAAD,EAAWC,OAAX,CAAf;AACD,GAJiC,CAMlC;AACA;AACA;AACA;;;AACA,QAAMO,IAAI,GAAGR,QAAQ,CAACS,KAAT,CAAe,GAAf,CAAb;AACA,QAAMN,GAAG,GAAGF,OAAO,CAACQ,KAAR,CAAc,GAAd,CAAZ,CAXkC,CAYlC;AACA;;AACA,MAAIC,KAAK,GAAG,KAAZ;AACA,MAAIC,QAAJ;AACA,MAAIC,OAAJ;;AAEA,OAAK,IAAIC,CAAC,GAAGV,GAAG,CAACW,MAAjB,EAAyBD,CAAC,GAAG,CAAJ,IAAS,CAACH,KAAnC,EAA0CG,CAAC,IAAI,CAA/C,EAAkD;AAChD;AACA,SAAK,IAAIE,CAAC,GAAGP,IAAI,CAACM,MAAL,GAAcD,CAA3B,EAA8BE,CAAC,IAAI,CAAL,IAAU,CAACL,KAAzC,EAAgDK,CAAC,IAAI,CAArD,EAAwD;AACtD;AACA;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAApB,EAAuBG,CAAC,IAAI,CAA5B,EAA+B;AAC7B,YAAIR,IAAI,CAACO,CAAC,GAAGC,CAAL,CAAJ,CAAYZ,OAAZ,CAAoB,SAApB,EAA+B,EAA/B,MAAuCD,GAAG,CAACa,CAAD,CAA9C,EAAmD;AACjDN,UAAAA,KAAK,GAAG,IAAR;;AACA,cAAIM,CAAC,KAAKH,CAAC,GAAG,CAAd,EAAiB;AACfF,YAAAA,QAAQ,GAAGE,CAAX;AACAD,YAAAA,OAAO,GAAGG,CAAC,GAAGF,CAAd;AACD;AACF,SAND,MAMO;AACLH,UAAAA,KAAK,GAAG,KAAR;AACA;AACD;AACF;AACF;AACF;;AAED,MAAIA,KAAJ,EAAW;AACT,WAAOF,IAAI,CAACS,KAAL,CAAW,CAAX,EAAcL,OAAd,EAAuBM,MAAvB,CAA8Bf,GAAG,CAACc,KAAJ,CAAUN,QAAV,CAA9B,EAAmDQ,IAAnD,CAAwD,GAAxD,CAAP;AACD,GAxCiC,CA0ClC;;;AACA,SAAOlB,OAAP;AACD;;AAEDmB,OAAO,CAACb,OAAR,GAAkBA,OAAlB","sourcesContent":["'use strict';\n\nfunction relative(basePath, relPath) {\n  const backPattern = /[^.]*\\.\\.\\//;\n  const rel = relPath.replace(/^\\.\\.?\\//, '');\n  let path;\n  if (!basePath) {\n    path = `${rel.replace(/^\\./, '')}`;\n  } else {\n    path = `${basePath}.${rel.replace(/^\\./, '')}`;\n  }\n  while (backPattern.test(path)) {\n    path = path.replace(backPattern, '');\n  }\n\n  return path;\n}\n\n/**\n * Resolve a full path from a base path and relative path\n * @param {string} basePath\n * @param {string} relPath\n */\nfunction resolve(basePath, relPath) {\n  // already relative, so easy work\n  if (/^\\.\\.?\\//.test(relPath)) {\n    return relative(basePath, relPath);\n  }\n\n  // otherwise we have to figure out if this is something like\n  // BEGIN a.b.c\n  // `- {a.b.c.d}\n  // or if it's an absolute path\n  const base = basePath.split('.');\n  const rel = relPath.split('.');\n  // find largest possible match in the base path\n  // decrease size of slice until a match is found\n  let found = false;\n  let relStart;\n  let baseLen;\n\n  for (let l = rel.length; l > 0 && !found; l -= 1) {\n    // slide through array from end to start until a match is found\n    for (let j = base.length - l; j >= 0 && !found; j -= 1) {\n      // check every element from (j) to (j + l) for equality\n      // if not equal, break right away\n      for (let i = 0; i < l; i += 1) {\n        if (base[j + i].replace(/\\[\\d+]$/, '') === rel[i]) {\n          found = true;\n          if (i === l - 1) {\n            relStart = l;\n            baseLen = j + l;\n          }\n        } else {\n          found = false;\n          break;\n        }\n      }\n    }\n  }\n\n  if (found) {\n    return base.slice(0, baseLen).concat(rel.slice(relStart)).join('.');\n  }\n\n  // assume its an absolute path\n  return relPath;\n}\n\nexports.resolve = resolve;\n"],"file":"paths.js"}