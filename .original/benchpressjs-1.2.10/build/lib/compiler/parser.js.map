{"version":3,"sources":["../../../lib/compiler/parser.js"],"names":["Close","require","tokens","paths","expressionPaths","basePath","expression","expr","Object","assign","tokenType","path","resolve","args","map","arg","subroutines","OpenIf","token","rest","iterSuffix","blockBody","tokensHandled","parse","test","body","OpenIter","subject","Else","RawMustache","EscapedMustache","Text","len","length","i","slice","branches","shouldBreak","push","parser","toks","reduce","prev","tok","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAYC,OAAO,CAAC,UAAD,CAAP,CAAoBC,MAAtC;;AACA,MAAMC,KAAK,GAAGF,OAAO,CAAC,SAAD,CAArB;AAEA;;;;;;;AAKA,SAASG,eAAT,CAAyBC,QAAzB,EAAmCC,UAAnC,EAA+C;AAC7C,QAAMC,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,UAAlB,CAAb;;AACA,MAAIC,IAAI,CAACG,SAAL,KAAmB,kBAAvB,EAA2C;AACzC,QAAIH,IAAI,CAACI,IAAL,KAAc,QAAlB,EAA4B;AAC1BJ,MAAAA,IAAI,CAACI,IAAL,GAAYN,QAAZ;AACD,KAFD,MAEO;AACLE,MAAAA,IAAI,CAACI,IAAL,GAAYR,KAAK,CAACS,OAAN,CAAcP,QAAd,EAAwBE,IAAI,CAACI,IAA7B,CAAZ;AACD;AACF,GAND,MAMO,IAAIJ,IAAI,CAACG,SAAL,KAAmB,kBAAvB,EAA2C;AAChDH,IAAAA,IAAI,CAACM,IAAL,GAAYN,IAAI,CAACM,IAAL,CAAUC,GAAV,CAAeC,GAAD,IAAS;AACjC,UAAIA,GAAG,CAACL,SAAJ,KAAkB,eAAtB,EAAuC;AACrC,eAAOK,GAAP;AACD;;AAED,aAAOX,eAAe,CAACC,QAAD,EAAWU,GAAX,CAAtB;AACD,KANW,CAAZ;AAOD;;AAED,SAAOR,IAAP;AACD;;AAED,MAAMS,WAAW,GAAG;AAClBC,EAAAA,MAAM,CAACC,KAAD,EAAQC,IAAR,EAAcd,QAAd,EAAwBe,UAAxB,EAAoC;AACxC,UAAM,CAACC,SAAD,EAAYC,aAAZ,IAA6BC,KAAK,CAACJ,IAAD,EAAOd,QAAP,EAAiBe,UAAjB,CAAxC;AAEA,UAAMI,IAAI,GAAGpB,eAAe,CAACC,QAAD,EAAWa,KAAK,CAACM,IAAjB,CAA5B;AACA,WAAO,CAAC,CAAChB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBS,KAAlB,EAAyB;AAAEM,MAAAA,IAAF;AAAQC,MAAAA,IAAI,EAAEJ;AAAd,KAAzB,CAAD,CAAD,EAAwDC,aAAxD,CAAP;AACD,GANiB;;AAOlBI,EAAAA,QAAQ,CAACR,KAAD,EAAQC,IAAR,EAAcd,QAAd,EAAwBe,UAAxB,EAAoC;AAC1C,UAAMT,IAAI,GAAGR,KAAK,CAACS,OAAN,CAAcP,QAAd,EAAwBa,KAAK,CAACS,OAAN,CAAchB,IAAtC,CAAb;AACA,UAAM,CAACU,SAAD,EAAYC,aAAZ,IAA6BC,KAAK,CAACJ,IAAD,EAAQ,GAAER,IAAK,IAAGS,UAAW,GAA7B,EAAiCA,UAAU,GAAG,CAA9C,CAAxC;AAEA,UAAMO,OAAO,GAAGnB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBS,KAAK,CAACS,OAAxB,EAAiC;AAAEhB,MAAAA;AAAF,KAAjC,CAAhB;AACA,WAAO,CACL,CAACH,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBS,KAAlB,EAAyB;AACxBO,MAAAA,IAAI,EAAEJ,SADkB;AAExBM,MAAAA,OAFwB;AAGxBP,MAAAA;AAHwB,KAAzB,CAAD,CADK,EAMLE,aANK,CAAP;AAQD,GApBiB;;AAqBlBM,EAAAA,IAAI,CAACV,KAAD,EAAQC,IAAR,EAAcd,QAAd,EAAwBe,UAAxB,EAAoC;AACtC,UAAM,CAACC,SAAD,EAAYC,aAAZ,IAA6BC,KAAK,CAACJ,IAAD,EAAOd,QAAP,EAAiBe,UAAjB,CAAxC;AACA,WAAO,CAAC,CAACZ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBS,KAAlB,EAAyB;AAAEO,MAAAA,IAAI,EAAEJ;AAAR,KAAzB,CAAD,CAAD,EAAkDC,aAAlD,CAAP;AACD,GAxBiB;;AAyBlBO,EAAAA,WAAW,CAACX,KAAD,EAAQC,IAAR,EAAcd,QAAd,EAAwB;AACjC,UAAMC,UAAU,GAAGF,eAAe,CAACC,QAAD,EAAWa,KAAK,CAACZ,UAAjB,CAAlC;AACA,WAAO,CAAC,CAACE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBS,KAAlB,EAAyB;AAAEZ,MAAAA;AAAF,KAAzB,CAAD,CAAD,EAA6C,CAA7C,CAAP;AACD,GA5BiB;;AA6BlBwB,EAAAA,eAAe,CAAC,GAAGjB,IAAJ,EAAU;AACvB,WAAOG,WAAW,CAACa,WAAZ,CAAwB,GAAGhB,IAA3B,CAAP;AACD,GA/BiB;;AAgClBkB,EAAAA,IAAI,CAACb,KAAD,EAAQ;AACV,WAAO,CAAC,CAACA,KAAD,CAAD,EAAU,CAAV,CAAP;AACD,GAlCiB;;AAmClBlB,EAAAA,KAAK,GAAG;AACN,WAAO,CAAC,EAAD,EAAK,CAAL,EAAQ,IAAR,CAAP;AACD;;AArCiB,CAApB;AAwCA;;;;;;;;AAOA,SAASuB,KAAT,CAAerB,MAAf,EAAuBG,QAAvB,EAAiCe,UAAjC,EAA6C;AAC3C,QAAMY,GAAG,GAAG9B,MAAM,CAAC+B,MAAnB;AACA,QAAMR,IAAI,GAAG,EAAb;AAEA,MAAIS,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGF,GAAX,EAAgB;AACd,UAAMd,KAAK,GAAGhB,MAAM,CAACgC,CAAD,CAApB;;AACA,QAAIlB,WAAW,CAACE,KAAK,CAACR,SAAP,CAAf,EAAkC;AAChC,YAAMS,IAAI,GAAGjB,MAAM,CAACiC,KAAP,CAAaD,CAAC,GAAG,CAAjB,CAAb;AACA,YAAM,CACJE,QADI,EAEJd,aAFI,EAGJe,WAHI,IAIFrB,WAAW,CAACE,KAAK,CAACR,SAAP,CAAX,CAA6BQ,KAA7B,EAAoCC,IAApC,EAA0Cd,QAA1C,EAAoDe,UAApD,CAJJ;AAMAK,MAAAA,IAAI,CAACa,IAAL,CAAU,GAAGF,QAAb;AAEAF,MAAAA,CAAC,IAAIZ,aAAL;;AAEA,UAAIe,WAAJ,EAAiB;AACf;AACD;AACF,KAfD,MAeO;AACLH,MAAAA,CAAC,IAAI,CAAL;AACD;AACF;;AAED,SAAO,CAACT,IAAD,EAAOS,CAAC,GAAG,CAAX,CAAP;AACD;AAED;;;;;;;AAKA,SAASK,MAAT,CAAgBrC,MAAhB,EAAwB;AACtB;AACA,QAAMsC,IAAI,GAAGtC,MAAM,CAACuC,MAAP,CAAc,CAACC,IAAD,EAAOC,GAAP,KAAe;AACxC,QAAIA,GAAG,CAACjC,SAAJ,KAAkB,MAAtB,EAA8B;AAC5B,aAAO,CAAC,GAAGgC,IAAJ,EAAU,IAAI1C,KAAJ,EAAV,EAAuB2C,GAAvB,CAAP;AACD;;AAED,WAAO,CAAC,GAAGD,IAAJ,EAAUC,GAAV,CAAP;AACD,GANY,EAMV,EANU,CAAb;AAQA,QAAM,CAAClB,IAAD,IAASF,KAAK,CAACiB,IAAD,EAAO,EAAP,EAAW,CAAX,CAApB;AACA,SAAOf,IAAP;AACD;;AAEDc,MAAM,CAACvB,WAAP,GAAqBA,WAArB;AAEA4B,MAAM,CAACC,OAAP,GAAiBN,MAAjB","sourcesContent":["'use strict';\n\nconst { Close } = require('./tokens').tokens;\nconst paths = require('./paths');\n\n/**\n * Resolve all expression paths relative to the loop\n * @param {string} basePath\n * @param {object} expression\n */\nfunction expressionPaths(basePath, expression) {\n  const expr = Object.assign({}, expression);\n  if (expr.tokenType === 'SimpleExpression') {\n    if (expr.path === '@value') {\n      expr.path = basePath;\n    } else {\n      expr.path = paths.resolve(basePath, expr.path);\n    }\n  } else if (expr.tokenType === 'HelperExpression') {\n    expr.args = expr.args.map((arg) => {\n      if (arg.tokenType === 'StringLiteral') {\n        return arg;\n      }\n\n      return expressionPaths(basePath, arg);\n    });\n  }\n\n  return expr;\n}\n\nconst subroutines = {\n  OpenIf(token, rest, basePath, iterSuffix) {\n    const [blockBody, tokensHandled] = parse(rest, basePath, iterSuffix);\n\n    const test = expressionPaths(basePath, token.test);\n    return [[Object.assign({}, token, { test, body: blockBody })], tokensHandled];\n  },\n  OpenIter(token, rest, basePath, iterSuffix) {\n    const path = paths.resolve(basePath, token.subject.path);\n    const [blockBody, tokensHandled] = parse(rest, `${path}[${iterSuffix}]`, iterSuffix + 1);\n\n    const subject = Object.assign({}, token.subject, { path });\n    return [\n      [Object.assign({}, token, {\n        body: blockBody,\n        subject,\n        iterSuffix,\n      })],\n      tokensHandled,\n    ];\n  },\n  Else(token, rest, basePath, iterSuffix) {\n    const [blockBody, tokensHandled] = parse(rest, basePath, iterSuffix);\n    return [[Object.assign({}, token, { body: blockBody })], tokensHandled];\n  },\n  RawMustache(token, rest, basePath) {\n    const expression = expressionPaths(basePath, token.expression);\n    return [[Object.assign({}, token, { expression })], 1];\n  },\n  EscapedMustache(...args) {\n    return subroutines.RawMustache(...args);\n  },\n  Text(token) {\n    return [[token], 1];\n  },\n  Close() {\n    return [[], 1, true];\n  },\n};\n\n/**\n * Parse an array of tokens into a syntax tree\n * @param {object[]} tokens\n * @param {string} basePath\n * @param {number} iterSuffix\n * @returns {[object[], number]}\n */\nfunction parse(tokens, basePath, iterSuffix) {\n  const len = tokens.length;\n  const body = [];\n\n  let i = 0;\n  while (i < len) {\n    const token = tokens[i];\n    if (subroutines[token.tokenType]) {\n      const rest = tokens.slice(i + 1);\n      const [\n        branches,\n        tokensHandled,\n        shouldBreak,\n      ] = subroutines[token.tokenType](token, rest, basePath, iterSuffix);\n\n      body.push(...branches);\n\n      i += tokensHandled;\n\n      if (shouldBreak) {\n        break;\n      }\n    } else {\n      i += 1;\n    }\n  }\n\n  return [body, i + 1];\n}\n\n/**\n * Parse an array of tokens into a syntax tree\n * @param {object[]} tokens\n * @returns {object}\n */\nfunction parser(tokens) {\n  // add Close token before each Else\n  const toks = tokens.reduce((prev, tok) => {\n    if (tok.tokenType === 'Else') {\n      return [...prev, new Close(), tok];\n    }\n\n    return [...prev, tok];\n  }, []);\n\n  const [body] = parse(toks, '', 1);\n  return body;\n}\n\nparser.subroutines = subroutines;\n\nmodule.exports = parser;\n"],"file":"parser.js"}