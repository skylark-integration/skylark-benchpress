{"version":3,"sources":["../../../lib/compiler/prefixer.js"],"names":["fixIter","input","replace","str","one","two","t","transforms","mustache","block","lone","raw","helperName","argStr","prefixer","reduce","prev","transform","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,KAAK,IAAIA,KAAK,CAACC,OAAN,CACvB,sEADuB,EAEvB,CAACC,GAAD,EAAMC,GAAN,EAAWC,GAAX,KAAmB;AACjB,QAAMC,CAAC,GAAGN,OAAO,CAACK,GAAD,CAAjB;AACA,SAAQ,cAAaD,GAAI,qBAAoBA,GAAI,OAAME,CAAE,eAAcF,GAAI,+BAA8BA,GAAI,OAAME,CAAE,YAAWF,GAAI,qBAAoBA,GAAI,MAA5J;AACD,CALsB,CAAzB;;AAQA,MAAMG,UAAU,GAAG,CACjB;AACAN,KAAK,IAAIA,KAAK,CAACC,OAAN,CAAc,4BAAd,EAA4C,uBAA5C,CAFQ,EAGjB;AACA;AACA;AACAD,KAAK,IAAIA,KAAK,CAACC,OAAN,CACP,sEADO,EAEP,CAACC,GAAD,EAAMC,GAAN,EAAWC,GAAX,KAAmB;AACjB,QAAMC,CAAC,GAAGN,OAAO,CAACK,GAAD,CAAjB;AACA,SAAQ,cAAaD,GAAI,OAAME,CAAE,YAAWF,GAAI,MAAhD;AACD,CALM,CANQ,EAajB;AACA;AACAH,KAAK,IAAIA,KAAK,CAACC,OAAN,CACP,4DADO,EAEP,CAACC,GAAD,EAAMK,QAAN,EAAgBC,KAAhB,EAAuBC,IAAvB,KAAgC;AAC9B,MAAIA,IAAJ,EAAU;AACR,WAAQ,IAAGA,IAAK,GAAhB;AACD;;AAED,SAAOP,GAAP;AACD,CARM,CAfQ,EAyBjB;AACAF,KAAK,IAAIA,KAAK,CAACC,OAAN,CACP,iEADO,EAEP,CAACS,GAAD,EAAMC,UAAN,EAAkBC,MAAlB,KAA8B,oBAAmBD,UAAW,UAASC,MAAM,GAAI,KAAIA,MAAO,EAAf,GAAmB,EAAG,MAF1F,CA1BQ,CAAnB;AAgCA;;;;;;AAKA,SAASC,QAAT,CAAkBb,KAAlB,EAAyB;AACvB,SAAOM,UAAU,CAACQ,MAAX,CAAkB,CAACC,IAAD,EAAOC,SAAP,KAAqBA,SAAS,CAACD,IAAD,CAAhD,EAAwDf,KAAxD,CAAP;AACD;;AAEDa,QAAQ,CAACP,UAAT,GAAsBA,UAAtB;AAEAW,MAAM,CAACC,OAAP,GAAiBL,QAAjB","sourcesContent":["'use strict';\n\nconst fixIter = input => input.replace(\n  /<!-- BEGIN ([^./][@a-zA-Z0-9/.\\-_:]+?) -->([\\s\\S]*?)<!-- END \\1 -->/g,\n  (str, one, two) => {\n    const t = fixIter(two);\n    return `<!-- IF ../${one} --><!-- BEGIN ../${one} -->${t}<!-- END ../${one} --><!-- ELSE --><!-- BEGIN ${one} -->${t}<!-- END ${one} --><!-- ENDIF ../${one} -->`;\n  }\n);\n\nconst transforms = [\n  // add value context for in-loop helpers\n  input => input.replace(/\\{function\\.([^}\\n ,]+)\\}/g, '{function.$1, @value}'),\n  // `<!-- BEGIN stuff -->` => `<!-- BEGIN ../stuff -->` and `<!-- BEGIN stuff -->`\n  // we need to add the fallback by duplicating under a different key\n  // only apply to nested blocks\n  input => input.replace(\n    /<!-- BEGIN ([^./][@a-zA-Z0-9/.\\-_:]+?) -->([\\s\\S]*?)<!-- END \\1 -->/g,\n    (str, one, two) => {\n      const t = fixIter(two);\n      return `<!-- BEGIN ${one} -->${t}<!-- END ${one} -->`;\n    }\n  ),\n  // wrap `@key`, `@value`, `@index` in mustaches\n  // if they aren't in a mustache already\n  input => input.replace(\n    /(\\{{1,2}[^}]+\\}{1,2})|(<!--[^>]+-->)|(@key|@value|@index)/g,\n    (str, mustache, block, lone) => {\n      if (lone) {\n        return `{${lone}}`;\n      }\n\n      return str;\n    }\n  ),\n  // add root data to if helpers\n  input => input.replace(\n    /<!-- IF (?:function\\.([@a-zA-Z0-9/._:]+)(?:\\s*,\\s*)?(.*?)) -->/g,\n    (raw, helperName, argStr) => `<!-- IF function.${helperName}, @root${argStr ? `, ${argStr}` : ''} -->`\n  ),\n];\n\n/**\n * Apply text-based fixes for backward compatibility\n * @param {string} input\n * @returns {string}\n */\nfunction prefixer(input) {\n  return transforms.reduce((prev, transform) => transform(prev), input);\n}\n\nprefixer.transforms = transforms;\n\nmodule.exports = prefixer;\n"],"file":"prefixer.js"}