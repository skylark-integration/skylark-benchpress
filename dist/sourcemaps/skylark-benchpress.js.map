{"version":3,"sources":["skylark-benchpress.js"],"names":["define","skylark","runtime","guard","value","Array","isArray","length","iter","obj","each","output","keys","Object","i","key","helper","context","helpers","helperName","args","out","apply","e","Promise","try","fn","resolve","templateFunction","toString","Benchpress","registerHelper","name","escapeCharMap","&","<",">","\"","'","`","=","replaceChar","c","escapeChars","str","replace","String","cache","globals","setGlobal","assign","jQuery","extend","render","template","data","block","addGlobals","reject","promise","loader","then","load","blocks","flush","parse","callback","TypeError","setTimeout","err","console","error","registerLoader","attach","benchpress","main"],"mappings":"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","file":"../skylark-benchpress.js","sourcesContent":["define('skylark-benchpress/benchpress',[\n  \"skylark-langx/skylark\"\n],function (skylark) {\n  var runtime = function () {\n    'use strict';\n\n    /**\n     * Convert null and undefined values to empty strings\n     * @param {any} value\n     * @returns {string}\n     */\n\n    function guard(value) {\n      return value == null || Array.isArray(value) && value.length === 0 ? '' : value;\n    }\n\n    /**\n     * Iterate over an object or array\n     * @param {string[]} obj - Iteratee object / array\n     * @param {function} each - Callback to execute on each item\n     * @return {string}\n     */\n    function iter(obj, each) {\n      if (!obj || typeof obj !== 'object') {\n        return '';\n      }\n\n      var output = '';\n      var keys = Object.keys(obj);\n      var length = keys.length;\n\n      for (var i = 0; i < length; i += 1) {\n        var key = keys[i];\n        output += each(key, i, length, obj[key]);\n      }\n\n      return output;\n    }\n\n    /**\n     * Execute a helper\n     * @param {object} context - Base data object\n     * @param {object} helpers - Map of helper functions\n     * @param {string} helperName - Name of helper to execute\n     * @param {any[]} args - Array of arguments\n     * @returns {string}\n     */\n    function helper(context, helpers, helperName, args) {\n      if (typeof helpers[helperName] !== 'function') {\n        return '';\n      }\n      try {\n        var out = helpers[helperName].apply(context, args);\n        return out || '';\n      } catch (e) {\n        return '';\n      }\n    }\n\n    /**\n     * Run a compiled template function\n     * @param {object} helpers - Map of helper functions\n     * @param {object} context - Base data object\n     * @param {function} templateFunction - Compiled template function\n     * @returns {string}\n     */\n    function runtime(helpers, context, templateFunction) {\n      return guard(templateFunction(helpers, context, guard, iter, helper)).toString();\n    }\n\n    // polyfill for Promise.try\n    if (typeof Promise.try !== 'function') {\n      Promise.try = {\n        try: function _try(fn) {\n          return new Promise(function (resolve) {\n            return resolve(fn());\n          });\n        }\n      }.try;\n    }\n\n    return runtime;\n  }();\n\n  'use strict';\n\n  /** @exports Benchpress */\n  var Benchpress = {};\n\n  Benchpress.runtime = runtime;\n\n  Benchpress.helpers = {};\n\n  /**\n   * Register a helper function\n   * @param {string} name - Helper name\n   * @param {function} fn - Helper function\n   */\n  Benchpress.registerHelper = function registerHelper(name, fn) {\n    Benchpress.helpers[name] = fn;\n  };\n\n  // add default escape function for escaping HTML entities\n  var escapeCharMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  var replaceChar = function replaceChar(c) {\n    return escapeCharMap[c];\n  };\n  \n  var escapeChars = /[&<>\"'`=]/g;\n\n  Benchpress.registerHelper('__escape', function (str) {\n    if (str == null) {\n      return '';\n    }\n    if (!str) {\n      return String(str);\n    }\n\n    return str.toString().replace(escapeChars, replaceChar);\n  });\n\n  Benchpress.cache = {};\n\n  Benchpress.globals = {};\n\n  /**\n   * Set a global data value\n   * @param {string} key - Property key\n   * @param {Object} value - Property value\n   */\n  Benchpress.setGlobal = function setGlobal(key, value) {\n    Benchpress.globals[key] = value;\n  };\n\n  var assign = Object.assign || jQuery.extend; // eslint-disable-line\n\n  /**\n   * @private\n   */\n  Benchpress.addGlobals = function addGlobals(data) {\n    return assign({}, Benchpress.globals, data);\n  };\n\n  /**\n   * Clear the template cache\n   */\n  Benchpress.flush = function flush() {\n    Benchpress.cache = {};\n  };\n\n  // necessary to support both promises and callbacks\n  // can remove when `parse` methods are removed\n  function load(template) {\n    return new Promise(function (resolve, reject) {\n      var promise = Benchpress.loader(template, function (templateFunction) {\n        resolve(templateFunction);\n      });\n\n      if (promise && promise.then) {\n        promise.then(resolve, reject);\n      }\n    });\n  }\n\n  /**\n   * Fetch and run the given template\n   * @param {string} template - Name of template to fetch\n   * @param {Object} data - Data with which to run the template\n   * @param {string} [block] - Parse only this block in the template\n   * @returns {Promise<string>} - Rendered output\n   */\n  function render(template, data, block) {\n    data = Benchpress.addGlobals(data || {});\n\n    return Promise.try(function () {\n      Benchpress.cache[template] = Benchpress.cache[template] || load(template);\n      return Benchpress.cache[template];\n    }).then(function (templateFunction) {\n      if (block) {\n        templateFunction = templateFunction.blocks && templateFunction.blocks[block];\n      }\n      if (!templateFunction) {\n        return '';\n      }\n\n      return runtime(Benchpress.helpers, data, templateFunction);\n    });\n  }\n\n  /**\n   * Alias for {@link render}, but uses a callback\n   * @param {string} template - Name of template to fetch\n   * @param {string} [block] - Render only this block in the template\n   * @param {Object} data - Data with which to run the template\n   * @param {function} callback - callback(output)\n   *\n   * @deprecated - Use {@link render} instead\n   */\n  function parse(template, block, data, callback) {\n    if (!callback && typeof block === 'object' && typeof data === 'function') {\n      callback = data;\n      data = block;\n      block = null;\n    }\n    if (typeof callback !== 'function') {\n      // Calling parse synchronously with no callback is discontinued\n      throw TypeError('Invalid Arguments: callback must be a function');\n    }\n    if (!template) {\n      callback('');\n      return;\n    }\n\n    render(template, data, block).then(function (output) {\n      return setTimeout(callback, 0, output);\n    }, function (err) {\n      return console.error(err);\n    } // eslint-disable-line no-console\n    );\n  }\n\n  Benchpress.render = render;\n  Benchpress.parse = parse;\n\n  /**\n   * Register a loader function to fetch templates\n   * - `loader(name, callback) => callback(templateFunction)`\n   * - `loader(name) => Promise<templateFunction>`\n   * @param {function} loader\n   */\n  Benchpress.registerLoader = function registerLoader(loader) {\n    Benchpress.loader = loader;\n  };\n\n  return skylark.attach(\"itg.benchpress\",Benchpress);\n\n});\ndefine('skylark-benchpress/main',[\r\n\t\"./benchpress\"\r\n],function(benchpress) {\r\n\r\n\treturn benchpress;\r\n});\ndefine('skylark-benchpress', ['skylark-benchpress/main'], function (main) { return main; });\n\n"]}